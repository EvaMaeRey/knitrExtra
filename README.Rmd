---
output: 
  github_document:
    toc: TRUE
    toc_depth: 2
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = T
)
```


# Part 0. Proposal

Proposing the {knitrExtra} package! 🦄 
<!-- (typical package introduction write up; but actually aspirational) -->

The goal of {knitrExtra} is to make some of my favorite functionality a little more accessible and usable interactively (in RStudio, I'm pretty much piggy backing on Kelly Bodwin's work on this).




Without the package, we live in the effort-ful world that follows 🏋:

```{r}
knitr::knit_code$get("times_two") |> as.vector()
knitr::knit_code$get() |> names()



```

  
With the {xxxx} package, we'll live in a different world (🦄 🦄 🦄) where the task is a snap 🫰: 

Proposed API:

```

library(xxxxx)

xxxxx::times_two(x = 4)

```



# Part I. Work out functionality  🚧 ✅ 

Here is a function that will do some work...


```{r chunk_code_get_static}
chunk_code_get_static <- function(chunk_name){
  
  knitr::knit_code$get(chunk_name) |> as.vector()
  
}
```

```{r chunk_names_get_static}
chunk_names_get_static <- function(){
  
  knitr::all_labels()
  
}
```

```{r}
knitr::knit_code$get()
```

## Try it out

```{r}
chunk_code_get_static("chunk_code_get_static")
chunk_code_get_static("chunk_names_get_static")
```


```{r}
# Awesome!
check_is_live <- function(){
  
  is_live <- FALSE
  
  # Check to see if we're in editor context
  if (requireNamespace("rstudioapi", quietly = TRUE) &&
      rstudioapi::isAvailable()) {

    is_live <- tryCatch({
      rstudioapi::getSourceEditorContext()
      TRUE
    }, error = function(e) FALSE)

  }  
  
  return(is_live)
  
}

# so cool!
text_chunk_extract <- function(.text, chunk_name) {

  # Find the start of the desired chunk
  chunk_regex <- paste0('\\`\\`\\`\\{[A-z]+ ', chunk_name, '(\\}|(,.*\\}))$')

  start_chunk <- .text |>
    stringr::str_which(chunk_regex)

  if (length(start_chunk) == 0) {

    stop(paste0("Error: No chunk found with name '", chunk_name, "'"))

  } else if (length(start_chunk) > 1) {

    stop(paste0("Error: Duplicate chunk name '", chunk_name, "'"))

  }

  end_chunk <- .text[-c(1:start_chunk)] |>
    stringr::str_which(stringr::fixed("```")) |>
    min() + start_chunk

  chunk_text <- .text[(start_chunk):(end_chunk)] |>
    stringr::str_c(collapse = "\n")

  attributes(chunk_text) <- NULL

  return(chunk_text)

}

chunk_remove_fencing_and_options <- function(code_chunk){
  
  # does not yet, in fact, remove options like these: 
  # | my-chunk, echo = FALSE, fig.width = 10,
  # | fig.cap = "This is a long long
  # |   long long caption."
  
 chunk_as_vec <- stringr::str_split(code_chunk,"\\n")[[1]] 
 
 # remove fencing which are first and last lines
 return(chunk_as_vec[2:(length(chunk_as_vec)-1)])
  
}

# wow!
return_chunk_code_live <- function(chunk_name) {

  
    ed        <- rstudioapi::getSourceEditorContext()
    source    <- ed$contents

    # can we use knitr tools to directly parse source for us? 
    # tmp       <- tempfile()
    # writeLines(source, tmp)
    # readLines(tmp)
    # knitr::knit_code$get(name = tmp)
    
    my_code_chunk  <- text_chunk_extract(.text = source, chunk_name)

    # If neither of those worked, error
    if (is.null(my_code_chunk)) {

    stop(paste0("Error: No chunk found with name '", chunk_name, "'"))

    }

    # remove chunk fencing, first and last lines
    my_code <- chunk_remove_fencing_and_options(my_code_chunk)
    
    return(my_code)
  
}

#' Title
#'
#' @param chunk_name a character string with the name of the chunk of interest
#'
#' @return a vector of the code contained in the referenced chunk
#' @export 
#'
#' @examples
chunk_code_get <- function(chunk_name){
  
  is_live <- check_is_live()
  
  if(is_live){
    return_chunk_code_live(chunk_name)
  }else{
  chunk_code_get_static(chunk_name = chunk_name)
    }

}
```


```{r}
chunk_code_get("chunk_code_get_static")
```


```{r, eval = F}
chunk_names_get_live <- function(chunk_name) {

    ed        <- rstudioapi::getSourceEditorContext()
    source    <- ed$contents

    
    first_fence <- source[grep("\\`\\`\\`\\{r ", source)]
    
    names_of_named_chunks <- first_fence |> 
      stringr::str_remove("\\`\\`\\`\\{r ") |>
      stringr::str_remove(",.+")

    names_of_named_chunks
    
}
```


```{r chunk_names_get}
chunk_names_get <- function(){
  
  is_live <- check_is_live()
  
  if(is_live){
    chunk_names_get_live()
  }else{
  chunk_names_get_static()
    }

}
```


```{r chunk_to_dir}
chunk_to_dir <- function (chunk_name, dir = "R/", extension = ".R") 
{
    for (i in 1:length(chunk_name)) {
        writeLines(paste(chunk_code_get(chunk_name = chunk_name[i]), 
            collapse = "\n"), con = paste0(dir, "/", chunk_name[i], 
            extension))
    }
}
```


# Part II. Packaging and documentation  🚧 ✅ 

## Phase 1. Minimal working package

### Bit A. Created package archetecture, running `devtools::create(".")` in interactive session. 🚧 ✅


```{r, eval = F}
devtools::create(".") # Bit 1. 1X
### Bit 2a: dependencies to functions using '::' syntax to pkg functions 
usethis::use_package("ggplot2") # Bit 2b: document dependencies
readme2pkg::chunk_to_r(chunk_name = "times_two") # Bit 3: send code chunk with function to R folder
devtools::check(pkg = ".")  # Bit 4: check that package is minimally viable
devtools::install(pkg = ".", upgrade = "never") # Bit 5: install package locally
usethis::use_lifecycle_badge("experimental") # Bit 6: add lifecycle badge
# Bit 7 (below): Write traditional readme
# Bit 8: Compile readme
# Bit 9: Push to githup
# Bit 10: listen and iterate
```


### Bit 7. Write traditional README that uses built package (also serves as a test of build). 🚧 ✅ 

The goal of the {xxxx} package is to ...

Install package with:

```
remotes::install_github("GithubCoolUser/mypacakge")
```

Once functions are exported you can remove go to two colons, and when things are are really finalized, then go without colons (and rearrange your readme...)

```{r, eval = F}
library(mypackage)  ##<< change to your package name here
mypackage:::times_two(10)
```

## Phase 3: Settling and testing 🚧 ✅ 

### Bit A. Added a description and author information in the [DESCRIPTION file](https://r-pkgs.org/description.html) 🚧 ✅

### Bit B. Added [roxygen skeleton](https://r-pkgs.org/man.html)? 🚧 ✅

### Bit C. Chosen a [license](https://r-pkgs.org/license.html)? 🚧 ✅

```{r, eval = F}
usethis::use_mit_license()
```


### Bit D. Settle on [examples](https://r-pkgs.org/man.html#sec-man-examples).  Put them in the roxygen skeleton and readme. 🚧 ✅

### Bit E. Written formal [tests](https://r-pkgs.org/testing-basics.html) of functions and save to test that folders 🚧 ✅


That would look like this...

```{r test_calc_times_two_works, eval = F}
library(testthat)

test_that("calc times 2 works", {
  expect_equal(times_two(4), 8)
  expect_equal(times_two(5), 10)
  
})
```


```{r, eval = F}
readme2pkg::chunk_to_tests_testthat("test_calc_times_two_works")
```




### Bit F. Check again. Addressed notes, warnings and errors. 🚧 ✅


```{r, eval = F}
devtools::check(pkg = ".")
```

## Phase 4. Promote to wider audience...  🚧 ✅ 

### Bit A. Package website built? 🚧 ✅


### Bit B. Package website deployed? 🚧 ✅

## Phase 5: Harden/commit: Submit to CRAN/RUniverse 🚧 ✅ 

# Appendix: Reports, Environment

## Description file complete?  🚧 ✅

```{r, eval = F}
readLines("DESCRIPTION")
```

## Environment  🚧 ✅

Here I just want to print the packages and the versions

```{r}
all <- sessionInfo() |> print() |> capture.output()
all[11:17]
```

## `devtools::check()` report

```{r, eval=F, error = T, results="hide", warning=F}
devtools::check(pkg = ".")
```

## Package directory file tree

```{r}
fs::dir_tree(recurse = T)
```



